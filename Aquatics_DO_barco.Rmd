---
title: "Aquatucs_DO_barco"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Read in packages
```{r}
#remotes::install_github("eco4cast/neon4cast")
library(tidyverse)
library(lubridate)
library(neonstore)
library(tidybayes)
library(modelr)
library(coda)
library(daymetr)
library(tidyverse)
library(tidybayes)
library(nimble)
library(imputeTS)
library(neon4cast)
Sys.setenv("NEONSTORE_HOME" = "neon_store/")
if(dir.exists("neon_store/")){
  dir.create("neon_store/")
}
```


read in EFI forecasty challenge data
```{r}
daily_data <- readr::read_csv("https://data.ecoforecast.org/targets/aquatics/aquatics-targets.csv.gz") %>% filter(siteID == "BARC")
```

Load NOAA met forecast data
```{r}
aq_sites <- unique(daily_data$siteID)
download_noaa(siteID = aq_sites, interval = "6hr", date = Sys.Date() - 2, cycle = "00")
noaa_fc <- stack_noaa()
noaa_fc
```

Tidy up forecast data
```{r}
ens_num = as.numeric(str_sub(noaa_fc$ensemble,4,5))
noaa_fc = noaa_fc %>% mutate(ensemble = ens_num)
noaa_fc = noaa_fc %>% mutate(startDate = as.POSIXct(startDate)) %>%
  mutate(DateTime = startDate + dhours(noaa_fc$time)) %>%
  mutate(air_temperature_C = air_temperature - 273.15) %>% 
  group_by(date(DateTime),ensemble) %>%
  mutate(time = date(DateTime)) %>%
  mutate(daily_temp = mean(air_temperature_C)) %>%
  ungroup(DateTime,ensemble)

noaa_fc %>% ggplot() +
  geom_path(aes(x=DateTime,y=daily_temp,colour=as.factor(ensemble)))
  
  
```



Visualize, interpolate, and fill in missing days
```{r}
#adding missing dates to interpolate 
dates_for_modelfit <- data.frame( time = seq(as.Date("2019-01-01"), as.Date("2020-06-08"), by="days")  )

#merge two data frame best on date so that dates w/out NAs are now in data frame just NA 
daily_data <- left_join(dates_for_modelfit, daily_data, by = "time") %>% 
  mutate(siteID = "BARC") #this is just to assign a site to Dates that don't have data for plotting below

#interpolate temp data
daily_data$temperature <- na_interpolation(daily_data$temperature)
daily_data$temperature_sd <- na_interpolation(daily_data$temperature_sd) 
daily_data$oxygen_sd <- na_interpolation(daily_data$oxygen_sd)

daily_data %>%
  ggplot(aes(x = time, y = temperature)) +
  geom_point() +
  facet_wrap(~siteID) +
  labs(x = "Date")
```
DO model
```{r}
Tmin <- daily_data$temperature
DO <- daily_data$oxygen
sd_obs <- daily_data$oxygen_sd


RandomWalk <- nimbleCode({
  
    #### Priors
  x[1] ~ dnorm(x_ic, sd=sd_ic)
  sd_add ~ dunif(0, 100)
  kdo ~ dnorm(0.005, sd=0.01)
  theta ~ dnorm(0.05, sd=0.01) 
  
    #### Process Model
  for(t in 2:n){
    pred[t] <-x[t-1] + theta - x[t-1] * kdo
    x[t] ~ dnorm(pred[t], sd=sd_add)
  }
  
  #### Data Model
  for(t in 1:n){
    y[t] ~ dnorm(x[t], sd=sd_obs[t])
  }
})

constants <- list(n = length(DO),
                  x_ic = 7.3,
                  sd_ic = 0.1,
                  sd_obs = sd_obs,
                  Tmin = Tmin)
data <- list(y = DO)
nchain = 3
inits <- list()

for(i in 1:nchain){
  y.samp = sample(DO, length(DO), replace = TRUE)
  inits[[i]] <- list(sd_add = sd(diff(na.omit(y.samp))),
                     x = DO,
                     kdo = rnorm(1, 0.005, 0.01),
                     theta = rnorm(1, 0.05, 0.01))
}

nimble_out <- nimbleMCMC(code = RandomWalk,
                         data = data,
                         inits = inits,
                         constants = constants,
                         monitors = c("sd_add",
                                       "x",
                                       "y",
                                      "kdo",
                                      "theta"),
                         niter = 18000,
                         nchains = 3,
                         samplesAsCodaMCMC = TRUE)

#plot(nimble_out)
plot(nimble_out[, c("sd_add")])
gelman.diag(nimble_out[, c("sd_add")])  ## determine convergence

## burn-in
burnin <- 8000                               
nimble_burn <- window(nimble_out, start = burnin)
plot(nimble_burn[, c("sd_add")])
plot(nimble_burn[, c("kdo")])
plot(nimble_burn[, c("theta")])
effectiveSize(nimble_burn[, c("sd_add")])
gelman.diag(nimble_burn[, c("sd_add")])  ## determine convergence

chain_dlm <- nimble_burn %>%
  spread_draws(y[day],x[day],sd_add) %>% 
  mutate(y = y,
         x = x)
chain_dlm %>% 
  summarize(sd_add = mean(sd_add))
```

Plot modeled vs. observed DO
```{r}
DO_pred <- chain_dlm %>% group_by(day) %>% 
            summarise(mean = mean(x, na.rm = TRUE),
            upper = quantile(x, 0.975),
            lower = quantile(x, 0.025),.groups = "drop") %>% 
             mutate(date = daily_data$time) 
  ggplot() +
  geom_line(data= DO_pred, aes(x = date, y = mean)) +
  geom_ribbon(data= DO_pred, aes(x = date, ymin = lower, ymax = upper), alpha = 0.2, color = "lightblue", fill = "lightblue") +
  geom_point(data = daily_data, aes(x = time, y = oxygen), shape=21, color="darkblue",size=1.5) + 
    scale_shape_identity() + labs(x = "Date", y = "DO (mg/L)", title = "DO model") 
```
Create forecast using forecasted NOAA temp
```{r}
#sample from posterior   
params <- nimble_burn %>%
  tidybayes::spread_draws(k20, theta, kdo, sd_add)
k20_values <- rnorm(length(params$k20),mean(params$k20),sd=params$sd_add)
theta_values <- rnorm(length(params$theta),mean(params$theta),sd=params$sd_add)
kdo_values <- rnorm(length(params$kdo),mean(params$kdo),sd=params$sd_add)

#figure out how to forecast
### settings            
Nmc <- 1000         ## set number of Monte Carlo draws
ylim <- c(-2, 11)  ## set Y range on plot
N.cols <- c("black") ## set colors
trans <- 0.8       ## set transparancy
time_full <- 7    ## total time
time1 <- 3       ## calibration period
time2 <- 7  ## forecast period

forecastN <- function(IC, ppt, r, Kg, beta, alpha, Q = 0, n = Nmc){
  DOxy <- matrix(NA, n, 7)  ## storage
  DOprev <- IC           ## initialize
  for(t in 1:NT){
    K <- pmax(1, Kg + alpha + beta*log(ppt[, t] / 800))  ## calculate carrying capacity
    mu <- pmax(1, DOprev + r * DOprev * (1 - DOprev / K))   ## calculate mean
    DOxy[,t] <- rnorm(n, mu, Q)                         ## predict next step
    DOprev <- DOxy[, t]                                  ## update IC
  }
  return(N)
}

## calculate mean of all inputs
ppt.mean <- matrix(DO_pred$mean, 1, 7) ## driver
## parameters
params <- as.matrix(chain_dlm$y)
param.mean <- apply(params, 2, mean)
## initial conditions
IC <- as.matrix(chain_dlm$x)

N.det <- forecastN(IC = mean(IC[, "N[6,30]"]),
                   ppt = ppt.mean,
                   r = param.mean["r_global"],
                   Kg = param.mean["K_global"],
                   beta = param.mean["beta"],
                   alpha = param.mean["alpha_site[6]"],
                   Q = 0,  ## process error off
                   n = 1)

## Plot run
plot.run()
lines(time2, N.det, col = "purple", lwd = 3)
```

