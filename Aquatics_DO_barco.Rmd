---
title: "Aquatucs_DO_barco"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Read in packages
```{r}
library(tidyverse)
library(lubridate)
library(neonstore)
library(tidybayes)
library(modelr)
library(coda)
library(daymetr)
library(tidyverse)
library(tidybayes)
library(nimble)
library(imputeTS)
Sys.setenv("NEONSTORE_HOME" = "neon_store/")
if(dir.exists("neon_store/")){
  dir.create("neon_store/")
}
```


read in EFI forecasty challenge data
```{r}
daily_data <- readr::read_csv("https://data.ecoforecast.org/targets/aquatics/aquatics-targets.csv.gz") %>% filter(siteID == "BARC")
```


Visualize, interpolate, and fill in missing days
```{r}
#adding missing dates to interpolate 
dates_for_modelfit <- data.frame( time = seq(as.Date("2019-01-01"), as.Date("2020-06-08"), by="days")  )

#merge two data frame best on date so that dates w/out NAs are now in data frame just NA 
daily_data <- left_join(dates_for_modelfit, daily_data, by = "time") %>% 
  mutate(siteID = "BARC") #this is just to assign a site to Dates that don't have data for plotting below

#interpolate temp data
daily_data$temperature <- na_interpolation(daily_data$temperature)
daily_data$temperature_sd <- na_interpolation(daily_data$temperature_sd) 
daily_data$oxygen_sd <- na_interpolation(daily_data$oxygen_sd)

daily_data %>%
  ggplot(aes(x = time, y = temperature)) +
  geom_point() +
  facet_wrap(~siteID) +
  labs(x = "Date")
```

Run nimble model using random walk
```{r}
Tmin <- daily_data$temperature
DO <- daily_data$oxygen

RandomWalk <- nimbleCode({
  
    #### Priors
  x[1] ~ dnorm(x_ic, sd=sd_ic)
  sd_add ~ dunif(0, 100)

  
    #### Process Model
  for(t in 2:n){
    pred[t] <-x[t-1]
    x[t] ~ dnorm(pred[t], sd=sd_add)
  }
  
  #### Data Model
  for(t in 1:n){
    y[t] ~ dnorm(x[t], sd=sd_obs)
  }
})
constants <- list(n = length(DO),
                  x_ic = 7,
                  sd_ic = 0.1,
                  sd_obs = 0.1) 
data <- list(y = DO)
nchain = 3
inits <- list()
for(i in 1:nchain){
  y.samp = sample(DO, length(DO), replace = TRUE)
  inits[[i]] <- list(sd_add = sd(diff(na.omit(y.samp))),
                     x = DO)
}
nimble_out <- nimbleMCMC(code = RandomWalk,
                         data = data,
                         inits = inits,
                         constants = constants,
                         monitors = c("sd_add",
                                       "x",
                                       "y"),
                         niter = 11000,
                         nchains = 3,
                         samplesAsCodaMCMC = TRUE)
#plot(nimble_out)
plot(nimble_out[, c("sd_add")])
gelman.diag(nimble_out[, c("sd_add")])  ## determine convergence
## burn-in
burnin <- 1000                               
nimble_burn <- window(nimble_out, start = burnin)
plot(nimble_burn[, c("sd_add")])
effectiveSize(nimble_burn[, c("sd_add")])
gelman.diag(nimble_burn[, c("sd_add")])  ## determine convergence
chain_dlm <- nimble_burn %>%
  spread_draws(y[day],x[day],sd_add) %>% 
  mutate(y = y,
         x = x)
chain_dlm %>% 
  summarize(sd_add = mean(sd_add))
```

Plot modeled vs. observed DO
```{r}
DO_pred <- chain_dlm %>% group_by(day) %>% 
            summarise(mean = mean(x, na.rm = TRUE),
            upper = quantile(x, 0.975),
            lower = quantile(x, 0.025),.groups = "drop") %>% 
             mutate(date = daily_data$Date) 
  ggplot(data= DO_pred, aes(x = date, y = mean)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, color = "lightblue", fill = "lightblue") +
  geom_point(data = daily_data, aes(x = Date, y = dissolvedOxygen), shape=21, color="darkblue",size=2) + 
    scale_shape_identity() + labs(x = "Date", y = "DO (mg/L)", title = "Nimble DLM") 
```

Arrhenius + Michaelis-menten equation
```{r}
Tmin <- daily_data$temperature
DO <- daily_data$oxygen
sd_obs <- daily_data$oxygen_sd


RandomWalk <- nimbleCode({
  
    #### Priors
  x[1] ~ dnorm(x_ic, sd=sd_ic)
  sd_add ~ dunif(0, 100)
  kdo ~ dnorm(0.3, sd=0.01) #0.0014, sd=0.0001
  k20 ~ dnorm(1.1, sd=0.1) #
  theta ~ dnorm(1.05, sd=0.01) #1.05, sd=0.01
  
    #### Process Model
  for(t in 2:n){
    Kt[t] <- k20 * theta ^(Tmin[t]-20)
    pred[t] <- Kt[t] * (x[t-1] / (kdo * x[t-1]))
    x[t] ~ dnorm(pred[t], sd=sd_add)
  }
  
  #### Data Model
  for(t in 1:n){
    y[t] ~ dnorm(x[t], sd=sd_obs[t])
  }
})

constants <- list(n = length(DO),
                  x_ic = 8,
                  sd_ic = 0.1,
                  sd_obs = sd_obs_interp,
                  Tmin = Tmin_interp)
                  #kdo = 0.0014),
                  #k20 = 1.2,
                  #theta = 1.047)
data <- list(y = DO)
nchain = 3
inits <- list()

for(i in 1:nchain){
  y.samp = sample(DO, length(DO), replace = TRUE)
  inits[[i]] <- list(sd_add = sd(diff(y.samp)),
                     x = DO,
                     kdo = rnorm(1, 1, 0.1),
                     k20 = rnorm(1, 1, 0.1),
                     theta = rnorm(1, 1, 0.1))
}

nimble_out <- nimbleMCMC(code = RandomWalk,
                         data = data,
                         inits = inits,
                         constants = constants,
                         monitors = c("sd_add",
                                       "x",
                                       "y",
                                      "kdo",
                                      "k20",
                                      "theta"),
                         niter = 11000,
                         nchains = 3,
                         samplesAsCodaMCMC = TRUE)

#plot(nimble_out)
plot(nimble_out[, c("sd_add")])
gelman.diag(nimble_out[, c("sd_add")])  ## determine convergence

## burn-in
burnin <- 1000                               
nimble_burn <- window(nimble_out, start = burnin)
plot(nimble_burn[, c("sd_add")])
plot(nimble_burn[, c("kdo")])
plot(nimble_burn[, c("k20")])
plot(nimble_burn[, c("theta")])
effectiveSize(nimble_burn[, c("sd_add")])
gelman.diag(nimble_burn[, c("sd_add")])  ## determine convergence

chain_dlm <- nimble_burn %>%
  spread_draws(y[day],x[day],sd_add) %>% 
  mutate(y = y,
         x = x)
chain_dlm %>% 
  summarize(sd_add = mean(sd_add))
```

Plot modeled vs. observed DO
```{r}
DO_pred <- chain_dlm %>% group_by(day) %>% 
            summarise(mean = mean(x, na.rm = TRUE),
            upper = quantile(x, 0.975),
            lower = quantile(x, 0.025),.groups = "drop") %>% 
             mutate(date = daily_data$Date) 
  ggplot(data= DO_pred, aes(x = date, y = mean)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, color = "lightblue", fill = "lightblue") +
  geom_point(data = daily_data, aes(x = Date, y = dissolvedOxygen), shape=21, color="darkblue",size=2) + 
    scale_shape_identity() + labs(x = "Date", y = "DO (mg/L)", title = "Nimble DLM") 
```

DLM model from previous assignment
```{r}
Tmin <- daily_temp$tsdWaterTempMean
DO <- daily_data$dissolvedOxygen

# DO_noNAs <- ifelse(is.na(DO), DO_noNAs <- 0, DO_noNAs <- DO)
# Tmin_noNAs <- ifelse(is.na(Tmin), Tmin_noNAs <- 0, Tmin_noNAs <- Tmin)
sd_obs <- daily_data$dissolvedOxygenExpUncert

DLM <- nimbleCode({
   #### Priors
 x[1] ~ dnorm(x_ic, sd = sd_ic)
 sd_add ~ dunif(0, 100)
 beta_0 ~ dnorm(0, 50)
 beta_1 ~ dnorm(0, 50)
 beta_x ~ dnorm(0, 50)
 
   #### Process Model
 for(t in 2:n){
   pred[t] <- x[t-1] +  beta_0 + beta_1 * Tmin[t-1] + beta_x * x[t-1]
   x[t] ~ dnorm(pred[t], sd = sd_add)
 }
 #### Data Model
 for(t in 1:n){
   y[t] ~ dnorm(x[t], sd = sd_obs[t])
 }
})
constants <- list(n = length(DO),
                 x_ic = 8,
                 sd_ic = 0.1,
                 sd_obs = sd_obs_interp,
                 Tmin = Tmin_interp,
                 sd_obs = 0.15, # mean(daily_data$dissolvedOxygenExpUncert, na.rm = TRUE),
                 Tmin = Tmin)

data <- list(y = DO)
nchain = 3
inits <- list()
for(i in 1:nchain){
 y.samp = sample(DO, length(DO), replace = TRUE)
 inits[[i]] <- list(sd_add = sd(diff(y.samp)),
                    x = DO,
                    beta_0 = rnorm(1,3,0.1),
                    beta_1 = rnorm(1,3,0.1),
                    beta_x = rnorm(1,3,0.1))
}
nimble_out <- nimbleMCMC(code = DLM,
                        data = data,
                        inits = inits,
                        constants = constants,
                        monitors = c("sd_add",
                                     "beta_0",
                                     "beta_1",
                                     "beta_x",
                                      "x",
                                      "y"),
                        niter = 11000,
                        nchains = 3,
                        samplesAsCodaMCMC = TRUE)
# plot
plot(nimble_out[,c("sd_add")])
#gelman.diag(nimble_out)  ## determine convergence
## burn-in
burnin <- 1000
nimble_burn <- window(nimble_out, start = burnin)
plot(nimble_burn[, c("sd_add")])
#diagnose convergence
#chain_dlm <- nimble_burn %>%
#  spread_draws(y[day],x[day],sd_add) %>%
#  mutate(y = y,
#         x = x)
#chain_dlm %>%
#  summarize(sd_add = mean(sd_add))
```

Plot nimble DLM
```{r}
#DO_pred <- chain_dlm %>% group_by(day) %>% 
#            summarise(mean = mean(x),
#            upper = quantile(x, 0.975),
#            lower = quantile(x, 0.025),.groups = "drop") %>% 
#             mutate(date = daily_data$Date) 
#  ggplot(data= DO_pred, aes(x = date, y = mean)) +
#  geom_line() +
#  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, color = #"lightblue", fill = "lightblue") +
#  geom_point(data = daily_data, aes(x = Date, y = dissolvedOxygen), shape=21, #color="darkblue",size=2) + 
#    scale_shape_identity() + labs(x = "Date", y = "DO (mg/L)", title = "Nimble #DLM") 
```